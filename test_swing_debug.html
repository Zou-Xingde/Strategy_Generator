<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ³¢æ®µé¡¯ç¤ºèª¿è©¦æ¸¬è©¦</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: white;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            height: 400px;
            margin: 20px 0;
            border: 1px solid #333;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #2d3748;
            border-radius: 8px;
        }
        button {
            background: #4299e1;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #3182ce;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            background: #4a5568;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>ğŸ” æ³¢æ®µé¡¯ç¤ºèª¿è©¦æ¸¬è©¦</h1>
        
        <div class="controls">
            <h3>æ§åˆ¶é¢æ¿</h3>
            <button onclick="testAPI()">æ¸¬è©¦API</button>
            <button onclick="testSwingDisplay()">æ¸¬è©¦æ³¢æ®µé¡¯ç¤º</button>
            <button onclick="clearSwing()">æ¸…é™¤æ³¢æ®µ</button>
            <button onclick="clearLog()">æ¸…é™¤æ—¥èªŒ</button>
        </div>
        
        <div class="status" id="status">
            ç‹€æ…‹: æº–å‚™èª¿è©¦æ³¢æ®µé¡¯ç¤º
        </div>
        
        <div class="chart-container" id="chart"></div>
    </div>

    <script>
        let chart;
        let swingPoints = [];
        let swingLines = [];
        
        function updateStatus(message) {
            const status = document.getElementById('status');
            status.textContent += '\n' + new Date().toLocaleTimeString() + ': ' + message;
            status.scrollTop = status.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('status').textContent = 'ç‹€æ…‹: æ—¥èªŒå·²æ¸…é™¤';
        }
        
        // åˆå§‹åŒ–åœ–è¡¨
        function initChart() {
            const chartContainer = document.getElementById('chart');
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.offsetWidth,
                height: chartContainer.offsetHeight,
                layout: {
                    background: { color: '#1a1a1a' },
                    textColor: '#ffffff',
                },
                grid: {
                    vertLines: { color: '#2d3748' },
                    horzLines: { color: '#2d3748' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2d3748',
                },
                timeScale: {
                    borderColor: '#2d3748',
                },
            });
            
            // æ·»åŠ è Ÿç‡­åœ–ç³»åˆ—
            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#00cc00',
                downColor: '#ff4444',
                borderVisible: false,
                wickUpColor: '#00cc00',
                wickDownColor: '#ff4444',
            });
            
            // æ·»åŠ ä¸€äº›æ¸¬è©¦æ•¸æ“š
            const testData = [
                { time: '2023-01-01', open: 1800, high: 1820, low: 1790, close: 1810 },
                { time: '2023-01-02', open: 1810, high: 1830, low: 1800, close: 1825 },
                { time: '2023-01-03', open: 1825, high: 1840, low: 1815, close: 1835 },
                { time: '2023-01-04', open: 1835, high: 1850, low: 1820, close: 1845 },
                { time: '2023-01-05', open: 1845, high: 1860, low: 1830, close: 1855 },
                { time: '2023-01-06', open: 1855, high: 1870, low: 1840, close: 1865 },
                { time: '2023-01-07', open: 1865, high: 1880, low: 1850, close: 1875 },
            ];
            
            candlestickSeries.setData(testData);
            updateStatus('åœ–è¡¨å·²åˆå§‹åŒ–');
        }
        
        // æ¸¬è©¦API
        async function testAPI() {
            try {
                updateStatus('æ­£åœ¨æ¸¬è©¦API...');
                
                const response = await fetch('/api/swing/XAUUSD/D1?algorithm=zigzag');
                updateStatus(`APIéŸ¿æ‡‰ç‹€æ…‹: ${response.status}`);
                
                const data = await response.json();
                updateStatus(`APIéŸ¿æ‡‰æ•¸æ“šé¡å‹: ${typeof data}`);
                updateStatus(`APIéŸ¿æ‡‰æ•¸æ“š: ${JSON.stringify(data, null, 2)}`);
                
                if (data.data && data.data.length > 0) {
                    updateStatus(`æ‰¾åˆ° ${data.data.length} å€‹æ³¢æ®µé»`);
                    updateStatus(`ç¬¬ä¸€å€‹æ³¢æ®µé»: ${JSON.stringify(data.data[0], null, 2)}`);
                } else {
                    updateStatus('æ²’æœ‰æ‰¾åˆ°æ³¢æ®µæ•¸æ“š');
                }
                
            } catch (error) {
                updateStatus(`APIæ¸¬è©¦å¤±æ•—: ${error.message}`);
                console.error('APIæ¸¬è©¦éŒ¯èª¤:', error);
            }
        }
        
        // æ¸¬è©¦æ³¢æ®µé¡¯ç¤º
        async function testSwingDisplay() {
            try {
                updateStatus('æ­£åœ¨æ¸¬è©¦æ³¢æ®µé¡¯ç¤º...');
                
                const response = await fetch('/api/swing/XAUUSD/D1?algorithm=zigzag');
                const data = await response.json();
                
                if (data.error) {
                    updateStatus(`APIéŒ¯èª¤: ${data.error}`);
                    return;
                }
                
                if (!data.data || data.data.length === 0) {
                    updateStatus('æ²’æœ‰æ‰¾åˆ°æ³¢æ®µæ•¸æ“š');
                    return;
                }
                
                // æ¸…é™¤ç¾æœ‰æ³¢æ®µ
                clearSwing();
                
                // æŒ‰æ™‚é–“æ’åº
                const sortedData = data.data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                updateStatus(`æ’åºå¾Œæ•¸æ“šæ•¸é‡: ${sortedData.length}`);
                
                // å‰µå»ºæ³¢æ®µé»æ•¸æ“š
                const swingPointsData = sortedData.map(point => {
                    let timestamp;
                    if (typeof point.timestamp === 'string') {
                        timestamp = new Date(point.timestamp);
                    } else if (typeof point.timestamp === 'number') {
                        timestamp = new Date(point.timestamp * 1000);
                    } else {
                        timestamp = new Date();
                    }
                    
                    return {
                        time: Math.floor(timestamp.getTime() / 1000),
                        value: parseFloat(point.zigzag_price),
                        type: point.zigzag_type
                    };
                });
                
                updateStatus(`è™•ç†å¾Œæ³¢æ®µé»æ•¸é‡: ${swingPointsData.length}`);
                updateStatus(`ç¬¬ä¸€å€‹è™•ç†å¾Œçš„æ³¢æ®µé»: ${JSON.stringify(swingPointsData[0], null, 2)}`);
                
                // æ·»åŠ æ³¢æ®µé»æ¨™è¨˜
                swingPointsData.forEach((point, index) => {
                    updateStatus(`æ·»åŠ æ³¢æ®µé» ${index + 1}: ${point.type} at ${point.time}`);
                    
                    const markerSeries = chart.addScatterPlotSeries({
                        color: point.type === 'high' ? '#ff4444' : '#00cc00',
                        size: 15,
                        shape: 'circle',
                        borderColor: '#ffffff',
                        borderWidth: 3,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                    
                    const markerData = [{
                        time: point.time,
                        value: point.value
                    }];
                    
                    markerSeries.setData(markerData);
                    swingPoints.push(markerSeries);
                });
                
                // å‰µå»ºé€£æ¥ç·š
                for (let i = 0; i < swingPointsData.length - 1; i++) {
                    const currentPoint = swingPointsData[i];
                    const nextPoint = swingPointsData[i + 1];
                    
                    updateStatus(`æ·»åŠ é€£æ¥ç·š ${i + 1}: ${currentPoint.time} -> ${nextPoint.time}`);
                    
                    const lineSeries = chart.addLineSeries({
                        color: getSwingLineColor(currentPoint.type, nextPoint.type),
                        lineWidth: 3,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        crosshairMarkerVisible: false,
                        lastValueVisible: false,
                        priceLineVisible: false,
                    });
                    
                    const lineData = [
                        { time: currentPoint.time, value: currentPoint.value },
                        { time: nextPoint.time, value: nextPoint.value }
                    ];
                    
                    lineSeries.setData(lineData);
                    swingLines.push(lineSeries);
                }
                
                updateStatus(`æˆåŠŸé¡¯ç¤º ${swingPointsData.length} å€‹æ³¢æ®µé»å’Œ ${swingLines.length} æ¢é€£æ¥ç·š`);
                
            } catch (error) {
                updateStatus(`æ³¢æ®µé¡¯ç¤ºæ¸¬è©¦å¤±æ•—: ${error.message}`);
                console.error('æ³¢æ®µé¡¯ç¤ºæ¸¬è©¦éŒ¯èª¤:', error);
            }
        }
        
        // æ¸…é™¤æ³¢æ®µ
        function clearSwing() {
            swingPoints.forEach(point => {
                if (point && chart) {
                    try {
                        chart.removeSeries(point);
                    } catch (e) {
                        console.warn('Error removing swing point:', e);
                    }
                }
            });
            swingPoints = [];
            
            swingLines.forEach(line => {
                if (line && chart) {
                    try {
                        chart.removeSeries(line);
                    } catch (e) {
                        console.warn('Error removing swing line:', e);
                    }
                }
            });
            swingLines = [];
            
            updateStatus('å·²æ¸…é™¤æ‰€æœ‰æ³¢æ®µé¡¯ç¤º');
        }
        
        // ç²å–æ³¢æ®µç·šé¡è‰²
        function getSwingLineColor(type1, type2) {
            if (type1 === 'low' && type2 === 'high') {
                return '#00cc00'; // ä¸Šå‡æ³¢æ®µ - ç¶ è‰²
            } else if (type1 === 'high' && type2 === 'low') {
                return '#ff4444'; // ä¸‹é™æ³¢æ®µ - ç´…è‰²
            } else {
                return '#888888'; // é»˜èªç°è‰²
            }
        }
        
        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        window.addEventListener('load', () => {
            updateStatus('é é¢å·²è¼‰å…¥ï¼Œæº–å‚™åˆå§‹åŒ–åœ–è¡¨');
            initChart();
        });
        
        // éŸ¿æ‡‰å¼èª¿æ•´
        window.addEventListener('resize', () => {
            if (chart) {
                chart.applyOptions({
                    width: document.getElementById('chart').offsetWidth,
                    height: document.getElementById('chart').offsetHeight,
                });
            }
        });
    </script>
</body>
</html> 